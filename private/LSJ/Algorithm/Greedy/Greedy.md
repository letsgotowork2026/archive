# Greedy Algorithm 
## 간단 설명
- 탐욕법 or 욕심쟁이 알고리즘
- `현재 상황에서 지금 당장 좋은 것만 고르는 방법`
- 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않음
  
## 코테에서는?
- 사전 암기 없이 풀수 있을 가능성이 높은 문제 유형
- 문제 출제 폭이 넓음
- 유형이 매우 다양해서 항상 잘 풀 수 있는 알고리즘이 아니다
- `가장 큰 순서대로`, `가장 작은 순서대로`와 같은 기준을 제시
- `정렬` 알고리즘과 짝을 이룸

## 거스름돈 문제
- `가장 큰 화폐 단위부터` 거슬러주기
- `거스름돈.py`
  - 화폐 종류 K개 일 때, O(K)
  - 거슬러줘야할 금액의 크기와는 무관

## 큰 수의 법칙
```
큰 수의 법칙'은 일반적으로 통계 분야에서 다루어지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다. 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M1번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스 (번호)에 해당하는 수가 연속 해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
예를 들어 순서대로 2.4. 5. 4. 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자.
이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과 는 6+6+6+5+6+6+6+5인 46이 된다.
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다. 예를 들어 순서 대로 3, 4.3,4. 3으로 이루어진 배열이 있을 때 M이 7이고, K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 결과적으로 4+4+4+4+4+4+4인 28이 도출된다. 배열의 크기 N. 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.
```

```
입력 조건
• 첫째 줄에 N(2 5 N S 1,000). M(1 ≤ M S 10,000). K(1 S KS 10,000)의 자연수가 주어 지며, 각 자연수는 공백으로 구분한다.
• 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10,000 이하의 수로 주어진다.
• 입력으로 주어지는 K는 항상 M보다 작거나 같다.
출력 조건
• 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.
입력 예시
583
24546
출력 예시
46
```
- 큰수의법칙.py
- 내 코드 출력
```
5 8 3
2 4 5 4 6
46
```
```
5 7 2
3 4 3 4 3
28
```

## Gemini가 뽑아준 핵심 문제 유형 5가지
### 1. 활동 선택 문제 (Activity Selection / Interval Scheduling)
가장 대표적인 그리디 유형입니다. 하나의 자원(회의실, 강의실)을 여러 활동이 공유할 때, 최대한 많은 활동을 배정하는 문제입니다.

핵심 키워드: #종료_시간_기준_정렬, #빨리_끝나는_것_우선, #다음_시작_시간_확인

풀이 전략: 시작 시간이 아무리 빨라도 늦게 끝나는 활동은 다른 활동을 방해합니다. 따라서 종료 시간을 기준으로 오름차순 정렬한 뒤, 이전 활동의 종료 시간보다 같거나 늦게 시작하는 활동을 순차적으로 선택합니다.

---

### 2. 분할 가능한 배낭 문제 (Fractional Knapsack)
무게 제한이 있는 배낭에 물건을 넣어 가치를 최대화하는 문제입니다. 물건을 '자르거나' '나눌 수 있는' 경우에만 그리디가 성립합니다.

핵심 키워드: #단위_무게당_가치, #가성비_위주_정렬, #그리디_vs_DP

풀이 전략: 무게 대비 가치가 가장 높은(가성비가 좋은) 물건부터 배낭에 가득 채웁니다. 남은 공간에는 다음 물건을 쪼개서 넣습니다.

주의: 물건을 쪼갤 수 없는 '0/1 배낭 문제'는 그리디가 아닌 **DP(다이나믹 프로그래밍)**로 풀어야 합니다.

---

### 3. 최소 신장 트리 (Minimum Spanning Tree - Kruskal)
그래프 내의 모든 정점을 가장 적은 비용으로 연결하는 경로를 찾는 문제입니다.

핵심 키워드: #간선_가중치_정렬, #Union_Find_자료구조, #사이클_방지

풀이 전략: 모든 간선을 가중치 기준으로 오름차순 정렬합니다. 가중치가 가장 낮은 간선부터 선택하되, Union-Find를 사용하여 이미 연결된 노드들 사이에 사이클이 생기지 않는 경우에만 선택을 확정합니다.

---

### 4. 허프만 코딩 (Huffman Coding)
문자의 빈도수에 따라 가변 길이 부호를 부여하여 데이터를 압축하는 알고리즘입니다.

핵심 키워드: #빈도수_기준, #Priority_Queue(우선순위_큐), #최소_힙(Min-Heap)

풀이 전략: 각 문자의 출현 빈도수를 구하고, 가장 빈도가 낮은 두 노드를 꺼내 합치는 과정을 반복하며 트리를 만듭니다. 이 과정에서 우선순위 큐를 사용하여 매번 가장 작은 값을 효율적으로 찾아내는 것이 핵심입니다.

https://syj-computer.tistory.com/40

---

### 5. 거스름돈 및 탐욕적 수 구성 (Change Making)
최소한의 동전 개수로 특정 금액을 만드는 전형적인 문제입니다.

핵심 키워드: #배수_관계_확인, #큰_단위_먼저, #나머지(%)_연산

풀이 전략: 가장 큰 단위의 동전부터 최대한 많이 사용합니다.

면접 꿀팁: 이 문제가 그리디로 풀리려면 반드시 **"큰 단위가 작은 단위의 배수"**여야 한다는 조건을 언급하세요. (예: 500원, 100원, 50원). 만약 400원, 300원, 100원처럼 배수 관계가 깨지면 그리디가 아닌 DP로 접근해야 함을 아는 것이 실력의 척도입니다.